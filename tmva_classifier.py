import uuid
from xml.etree import ElementTree

import ROOT
import numpy
import root_numpy.tmva


ROOT.TMVA.Tools.Instance()


class TMVAClassifierError(Exception):
    pass


class TMVAClassifier(object):
    """A TMVA classifier wrapper.

    Parameters
    ----------
    method : string, optional
        The name of the classification method, e.g. BDT or KNN.
        This is required unless loading a model from a weight file.
    name : string, optional
        The name of the trained classifier. This is used to keep
        track of the output files for the fit results and model
        weights generated by TMVA. The default is a long UUID.
    weights : path, optional
        The path to a TMVA XML weights file used to restore the model.
    **params
        All other keyword arguments are taken to be the model's
        hyperparameters and their values. If the model is loaded
        from a weights file, these additional keyword arguments
        are ignored.
    """
    def __init__(self, method=None, name=None, weights=None, **params):
        if weights:
            self._load_from_weights(weights)
        elif method is None:
            raise TMVAClassifierError('An MVA method must be specified when not loading a model from weights')
        else:
            self.method = method
            self.name = name or uuid.uuid4().hex
            self.params = params
            self._reader = None

    def __repr__(self):
        return "{0}(method='{1}', {2})".format(
            self.__class__.__name__,
            self.method,
            ', '.join('{0}={1!r}'.format(*param) for param in self.params.iteritems()),
        )

    def _load_from_weights(self, path):
        """Load a TMVA model from its XML weight file."""
        root = ElementTree.parse(path).getroot()
        self.name = root.attrib['Method']
        self.method = self.name.split('::')[0]
        # Only keep modified options.
        self.params = {}
        for node in root.findall('.//Option'):
            if node.attrib['modified'] == 'Yes':
                self.params[node.attrib['name']] = node.text
        # Setup the Reader to immediately enable inference.
        self._reader = ROOT.TMVA.Reader('Silent')
        for node in root.findall('.//Variable'):
            if node.attrib['Type'] == 'F':
                self._reader.AddVariable(node.attrib['Internal'], numpy.array([0], dtype=numpy.float32))
            elif node.attrib['Type'] == 'I':
                self._reader.AddVariable(node.attrib['Internal'], numpy.array([0], dtype=numpy.int32))
            else:
                raise TMVAClassifierError(
                    'Encountered unexpected variable type while loading weights from {0}: {1!r}'.format(path, node.attrib)
                )
        self._reader.BookMVA(self.name, path)

    @staticmethod
    def load_train_val_data(x, y, weights=None, validation_data=None):
        """Load training and validation data for use by TMVA.

        Parameters
        ----------
        x : numpy array-like
            The training data as an array of shape (n_samples, n_features).
            If the training data is passed as a pandas.DataFrame, the features
            will be referred to by their column name in TMVA. Otherwise, the
            features are referred to by a dummy name constructed by their column
            index.
        y : numpy array-like
            The target labels as an array of shape (n_samples, 1).
        weights : numpy array-like, optional
            The event weights for the training data as an array of shape (n_samples, 1).
        validation_data : tuple, optional
            The validation data as a tuple of (x_val, y_val) or (x_val, y_val, weights_val).
            This is usually referred to by TMVA as test data.

        Returns
        -------
        data_loader : ROOT.TMVA.DataLoader
            A DataLoader instance prepared with training and validation data.
        """
        data_loader = ROOT.TMVA.DataLoader()
        try:
            # Training data is DataFrame-like.
            for column in x.columns:
                if numpy.issubdtype(x[column].dtype, numpy.float):
                    data_loader.AddVariable(column, 'F')
                elif numpy.issubdtype(x[column].dtype, numpy.int):
                    data_loader.AddVariable(column, 'I')
                else:
                    raise TMVAClassifierError('Classification features must be a subtype of integer or float')
        except AttributeError:
            # Training data is ndarray-like.
            for i in xrange(len(x.dtype)):
                name = 'Var{0!s}'.format(i)
                dtype = x.dtype.fields['f{0!s}'.format(i)][0]
                if numpy.issubdtype(dtype, numpy.float):
                    data_loader.AddVariable(name, 'F')
                elif numpy.issubdtype(dtype, numpy.int):
                    data_loader.AddVariable(name, 'I')
                else:
                    raise TMVAClassifierError('Classification features must be a subtype of integer or float')
        except Exception:
            raise
        root_numpy.tmva.add_classification_events(data_loader, x, y, weights=weights)
        if validation_data:
            if len(validation_data) == 2:
                x_val, y_val = validation_data
                add_classification_events(data_loader, x_val, y_val, test=True)
            elif len(validation_data) == 3:
                x_val, y_val, weights_val = validation_data
                root_numpy.tmva.add_classification_events(data_loader, x_val, y_val, weights=weights_val, test=True)
            else:
                raise ValueError(
                    '`validation_data` should be a tuple of `(x_val, y_val)` or'
                    '`(x_val, y_val, weights_val)`, found: {0!s}'.format(validation_data)
                )
        signal_cut = ROOT.TCut('')
        background_cut = ROOT.TCut('')
        data_loader.PrepareTrainingAndTestTree(signal_cut, background_cut, 'NormMode=None')
        return data_loader

    def fit(self, x, y, validation_data, weights=None, verbose=True):
        """Train the TMVA classifier.

        Parameters
        ----------
        x : numpy array-like
            The training data as an array of shape (n_samples, n_features).
            If the training data is passed as a pandas.DataFrame, the features
            will be referred to by their column name in TMVA. Otherwise, the
            features are referred to by a dummy name constructed by their column
            index.
        y : numpy array-like
            The target labels as an array of shape (n_samples, 1).
        validation_data : tuple
            The validation data as a tuple of (x_val, y_val) or (x_val, y_val, weights_val).
            This is usually referred to by TMVA as test data.
        weights : numpy array-like, optional
            The event weights for the training data as an array of shape (n_samples, 1).
        """
        outfile = ROOT.TFile.Open('TMVAClassifier_{0}.root'.format(self.name), 'recreate')
        tmva_options = 'AnalysisType=Classification:!DrawProgressBar'
        if not verbose:
            tmva_options += ':Silent'
        factory = ROOT.TMVA.Factory('TMVAClassifier', outfile, tmva_options)
        data_loader = self.load_train_val_data(x, y, weights, validation_data)
        method_options = ':'.join('{0}={1!s}'.format(*param) for param in self.params.iteritems())
        method = factory.BookMethod(data_loader, self.method, self.name, method_options)
        factory.TrainAllMethods()
        factory.TestAllMethods()
        factory.EvaluateAllMethods()
        outfile.Write()
        outfile.Close()

        # Load the model weights into a Reader to enable inference.
        self._reader = ROOT.TMVA.Reader('Silent')
        features = data_loader.GetDataSetInfo().GetVariableInfos()
        for feature in features:
            if feature.GetVarType() == 'F':
                self._reader.AddVariable(feature.GetInternalName(), numpy.array([0], dtype=numpy.float32))
            elif feature.GetVarType() == 'I':
                self._reader.AddVariable(feature.GetInternalName(), numpy.array([0], dtype=numpy.int32))
            else:
                raise TMVAClassifierError('Classification features must be a subtype of integer or float')
        self._reader.BookMVA(self.name, 'default/weights/TMVAClassifier_{0}.weights.xml'.format(self.name))
        return self

    def evaluate(self, x):
        """Evaluate the classifier on a set of examples.

        Parameters
        ----------
        x : numpy array-like
            An array of shape (n_samples, n_features). The features must be
            provided in the same order presented during training.

        Returns
        -------
        numpy array
            The classifier output values as a numpy array of shape (n_samples, 1).
        """
        if self._reader:
            return root_numpy.tmva.evaluate_reader(self._reader, self.name, x)
        else:
            raise TMVAClassifierError('The classifier must be fit before predictions can be made')

    def cross_val(self, x, y, validation_data, weights=None, n_folds=None):
        """Perform k-fold cross validation for the TMVA classifier.

        Parameters
        ----------
        x : numpy array-like
            The training data as an array of shape (n_samples, n_features).
            If the training data is passed as a pandas.DataFrame, the features
            will be referred to by their column name in TMVA. Otherwise, the
            features are referred to by a dummy name constructed by their column
            index.
        y : numpy array-like
            The target labels as an array of shape (n_samples, 1).
        validation_data : tuple
            The validation data as a tuple of (x_val, y_val) or (x_val, y_val, weights_val).
            This is usually referred to by TMVA as test data.
        weights : numpy array-like, optional
            The event weights for the training data as an array of shape (n_samples, 1).
        n_folds : int, optional
            The number of folds used for cross validation. The default is 5.

        Returns
        -------
        metrics : dict
            A dictionary of metrics evaluated over each cross validation fold:
                * eff01, the signal efficiency at 1% background efficiency
                * eff10, the signal efficiency at 10% background efficiency
                * eff30, the signal efficiency at 30% background efficiency
                * auroc, the area under the ROC curve
                * separation, the amount of overlap between the signal and
                  background probability distribution functions (PDFs)
                * significance, the significance of the difference between
                  the mean classifier values for signal and background
            For more information about these metrics, please see the TMVA User's
            Guide section on classification performance evaluation (3.1.10).
        """
        data_loader = self.load_train_val_data(x, y, weights, validation_data)
        cv = ROOT.TMVA.CrossValidation(data_loader)
        cv.SetNumFolds(n_folds or 5)
        method_options = ':'.join('{0}={1!s}'.format(*param) for param in self.params.iteritems())
        cv.BookMethod(self.method, self.name, method_options)
        cv.Evaluate()
        cv_results = cv.GetResults()
        metrics = {
            'eff01': list(cv_results.GetEff01Values()),
            'eff10': list(cv_results.GetEff10Values()),
            'eff30': list(cv_results.GetEff30Values()),
            'auroc': [fold[1] for fold in cv_results.GetROCValues()],
            'separation': list(cv_results.GetSepValues()),
            'significance': list(cv_results.GetSigValues()),
        }
        return metrics
